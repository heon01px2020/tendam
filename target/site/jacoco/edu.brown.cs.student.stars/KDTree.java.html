<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KDTree.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stars</a> &gt; <a href="index.source.html" class="el_package">edu.brown.cs.student.stars</a> &gt; <span class="el_source">KDTree.java</span></div><h1>KDTree.java</h1><pre class="source lang-java linenums">package edu.brown.cs.student.stars;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.PriorityQueue;

/**
 * Class that represents a KDTree.
 * @param &lt;T&gt; Any object that implements the HasCoordinate interface
 */
public class KDTree&lt;T extends HasCoordinate&gt; {
  private KDNode root;
  private int totalDimension;
  private int size;

  /**
   * CLass that represents a KDNode.
   */
  private class KDNode implements Comparable&lt;KDNode&gt; {
    private T value;
    private KDNode left, right;
    private int dimension;
    private double distance;

    /**
     * Creates a new Node object.
     * @param dim Integer representing which dimension this node is in
     * @param totalDim Integer representing total dimension
     */
<span class="fc" id="L32">    KDNode(T element, int dim, int totalDim) {</span>
<span class="fc" id="L33">      this.value = element;</span>
<span class="fc" id="L34">      this.left = null;</span>
<span class="fc" id="L35">      this.right = null;</span>
<span class="fc" id="L36">      this.dimension = dim % totalDim;</span>
<span class="fc" id="L37">    }</span>

    /**
     * Constructs a KDNode.
     */
<span class="fc" id="L42">    KDNode(T element) {</span>
<span class="fc" id="L43">      this.left = null;</span>
<span class="fc" id="L44">      this.right = null;</span>
<span class="fc" id="L45">      this.value = element;</span>
<span class="fc" id="L46">    }</span>

    /**
     * Gets the value of the node.
     * @return The value of the node
     */
    public T getValue() {
<span class="fc" id="L53">      return this.value;</span>
    }

    /**
     * Gets the left node of the node.
     * @return Left node of the node
     */
    public KDNode getLeft() {
<span class="fc" id="L61">      return this.left;</span>
    }

    /**
     * Gets the right node of the node.
     * @return Right node of the node
     */
    public KDNode getRight() {
<span class="fc" id="L69">      return this.right;</span>
    }

    /**
     * Gets the dimension of the node.
     * @return Integer representing dimension of the node
     */
    public int getDimension() {
<span class="fc" id="L77">      return this.dimension;</span>
    }

    public void setDimension(int dimension) {
<span class="fc" id="L81">      this.dimension = dimension;</span>
<span class="fc" id="L82">    }</span>

    /**
     * Sets the left node of the node.
     * @param leftNode Node to set
     */
    public void setLeft(KDNode leftNode) {
<span class="fc" id="L89">      this.left = leftNode;</span>
<span class="fc" id="L90">    }</span>

    /**
     * Sets the right node of the node.
     * @param rightNode Node to set
     */
    public void setRight(KDNode rightNode) {
<span class="fc" id="L97">      this.right = rightNode;</span>
<span class="fc" id="L98">    }</span>

    /**
     * Compares the current node's distance with another node.
     * @param node another node in the same dimension of space
     * @return 0 if two node have the same distance;
     *         1 if the current node's distance is larger; -1 if smaller
     */
    @Override
    public int compareTo(KDNode node) {
<span class="fc" id="L108">      return Double.compare(distance, node.distance);</span>
    }

    /**
     * Gets the significant fields as an array of objects.
     * @return significant field of KDNode object
     */
    private Object[] getSigFields() {
<span class="nc" id="L116">      Object[] result = {value, left, right, dimension, distance};</span>
<span class="nc" id="L117">      return result;</span>
    }

    /**
     * Overriding equality for KDNode object.
     *
     * @param secondKDNode KDNode to be checked if equal to this KDNode.
     * @return True if equal, false if unequal.
     */
    @Override
    public boolean equals(Object secondKDNode) {
<span class="nc bnc" id="L128" title="All 2 branches missed.">      if (secondKDNode == null) {</span>
<span class="nc" id="L129">        return false;</span>
      }
<span class="nc bnc" id="L131" title="All 2 branches missed.">      if (this == secondKDNode) {</span>
<span class="nc" id="L132">        return true;</span>
      }
<span class="nc bnc" id="L134" title="All 2 branches missed.">      if (secondKDNode.getClass() != this.getClass()) {</span>
<span class="nc" id="L135">        return false;</span>
      }
<span class="nc" id="L137">      KDNode second = (KDNode) secondKDNode;</span>

<span class="nc bnc" id="L139" title="All 2 branches missed.">      for (int i = 0; i &lt; this.getSigFields().length; ++i) {</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">        if (!Objects.equals(this.getSigFields()[i], second.getSigFields()[i])) {</span>
<span class="nc" id="L141">          return false;</span>
        }
      }
<span class="nc" id="L144">      return true;</span>
    }

    /**
     * Overrides hashCode.
     * @return Positive number if greater, 0 if same, negative if less
     */
    @Override
    public int hashCode() {
<span class="nc" id="L153">      return Objects.hash(getSigFields());</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L158">      return value.toString();</span>
    }
  }

  /**
   * Constructs a KDTree that contains coordinates in the specified dimension.
   * @param totalDimension dimension of KDTree
   */
<span class="fc" id="L166">  public KDTree(int totalDimension) {</span>
<span class="fc" id="L167">    this.root = null;</span>
<span class="fc" id="L168">    this.totalDimension = totalDimension;</span>
<span class="fc" id="L169">    this.size = 0;</span>
<span class="fc" id="L170">  }</span>

  /**
   * Constructs a KDTree with a list of nodes in the specified dimension.
   * @param totalDimension dimension of KDTree
   * @param nodes list of nodes to be constructed with
   */
<span class="fc" id="L177">  public KDTree(int totalDimension, List&lt;T&gt; nodes) {</span>
<span class="fc" id="L178">    this.totalDimension = totalDimension;</span>
<span class="fc" id="L179">    this.size = 0;</span>
<span class="fc" id="L180">    this.root = buildKDTreeHelper(nodes, 0);</span>
<span class="fc" id="L181">  }</span>

  /**
   * Gets the root node of the KDTree.
   * @return Root node of the KDTree
   */
  public KDNode getRoot() {
<span class="nc" id="L188">    return this.root;</span>
  }

  /**
   * Returns the size of a tree.
   * @return size
   */
  public int size() {
<span class="fc" id="L196">    return size;</span>
  }

  /**
   * Sorts a given list based on the given dimension.
   * @param l List to sort
   * @param dim Dimension to sort list by
   * @return Sorted list
   */
  public List&lt;T&gt; sortList(List&lt;T&gt; l, int dim) {
//    Collections.sort(l, new SortByDimension(
//            dim % this.totalDimension,
//            this.totalDimension));
<span class="fc" id="L209">    l.sort(new SortByDimension(dim % this.totalDimension));</span>
<span class="fc" id="L210">    return l;</span>
  }

  /**
   * Helper for building the KDTree.
   * @param nodes List of nodes to use to build KDTree
   * @param dim Current dimension of node
   * @return Node to add in KDTree
   */
  private KDNode buildKDTreeHelper(List&lt;T&gt; nodes, int dim) {
    // If list is empty, return the node
<span class="fc bfc" id="L221" title="All 2 branches covered.">    if (nodes.size() != 0) {</span>
      // Sorts the list to get median value
<span class="fc" id="L223">      List&lt;T&gt; sortedNodes = sortList(nodes, dim);</span>
<span class="fc" id="L224">      int medianIndex = sortedNodes.size() / 2;</span>
<span class="fc" id="L225">      KDNode n = new KDNode(sortedNodes.get(medianIndex), dim, this.totalDimension);</span>
<span class="fc" id="L226">      KDNode leftNode = buildKDTreeHelper(sortedNodes.subList(0, medianIndex), dim + 1);</span>
<span class="fc" id="L227">      KDNode rightNode = buildKDTreeHelper(sortedNodes.subList(medianIndex + 1,</span>
<span class="fc" id="L228">              sortedNodes.size()), dim + 1);</span>
<span class="fc" id="L229">      n.setLeft(leftNode);</span>
<span class="fc" id="L230">      n.setRight(rightNode);</span>
<span class="fc" id="L231">      this.size++;</span>
<span class="fc" id="L232">      return n;</span>
    }
<span class="fc" id="L234">    return new KDNode(null, dim, this.totalDimension);</span>
  }

  /**
   * Inserts an element into a KDTree.
   * Reports error if element is not in the same dimension as tree.
   * @param newElement element to be inserted
   */
  public void insert(T newElement) {
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">    if (newElement.getCoordinate().length != totalDimension) {</span>
<span class="nc" id="L244">      System.err.println(&quot;ERROR: New point not in the same dimension&quot;);</span>
    } else {
<span class="fc" id="L246">      KDNode newNode = new KDNode(newElement);</span>
<span class="fc" id="L247">      root = insertRecur(newNode, root, 0);</span>
<span class="fc" id="L248">      size += 1;</span>
    }
<span class="fc" id="L250">  }</span>

  /**
   * Recursive helper function for inserting a node into KDTree.
   * @param newNode      node to be inserted
   * @param currentNode  current node being looked at during recursion
   * @param currentDepth the level of depth that the function is at during recursion
   * @return the new root node after insertion
   */
  private KDNode insertRecur(KDNode newNode, KDNode currentNode, int currentDepth) {
<span class="fc bfc" id="L260" title="All 2 branches covered.">    if (currentNode == null) {</span>
<span class="fc" id="L261">      currentNode = newNode;</span>
<span class="fc" id="L262">      currentNode.setDimension(currentDepth % totalDimension);</span>
    } else {
      /* Recursively compares the coordinate of the newNode with the currentNode,
       * inserts the newNode into the correct subtree */
<span class="fc" id="L266">      int cd = currentDepth % totalDimension; //current dimension of comparison</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">      if (newNode.getValue().getCoordinate()[cd] &lt; currentNode.getValue().getCoordinate()[cd]) {</span>
<span class="fc" id="L268">        currentNode.left = insertRecur(newNode, currentNode.left, currentDepth + 1);</span>
      } else {
<span class="fc" id="L270">        currentNode.right = insertRecur(newNode, currentNode.right, currentDepth + 1);</span>
      }
    }
<span class="fc" id="L273">    return currentNode;</span>
  }

  /**
   * Inserts a list of elements into a KD tree.
   * @param elements list of elements
   */
  public void insertAll(List&lt;T&gt; elements) {
<span class="fc bfc" id="L281" title="All 2 branches covered.">    for (T elt : elements) {</span>
<span class="fc" id="L282">      insert(elt);</span>
<span class="fc" id="L283">    }</span>
<span class="fc" id="L284">  }</span>

  /* Global variable to store KNN */
  private BoundedPriorityQueue bpq;

  /**
   * Finds k nearest neighbors in the tree from coordinates.
   * @param k           number of neighbors to be found
   * @param coordinates coordinate around which to look for
   * @return a list of k nearest neighbors
   */
  public List&lt;T&gt; findKNN(int k, double[] coordinates) {
<span class="fc" id="L296">    bpq = new BoundedPriorityQueue(k);</span>
<span class="fc" id="L297">    findKNNRecur(k, root, coordinates);</span>
<span class="fc" id="L298">    List&lt;KDNode&gt; foundNodes = bpq.toList();</span>
<span class="fc" id="L299">    List&lt;T&gt; output = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">    for (KDNode node : foundNodes) {</span>
<span class="fc" id="L301">      output.add(node.getValue());</span>
<span class="fc" id="L302">    }</span>
<span class="fc" id="L303">    return output;</span>
  }

  /**
   * Recursive helper function for finding KNN.
   * @param k           number of neighbors to be found
   * @param currentNode current node being looked at during recursion
   * @param coordinates coordinate around which to look for
   */
  private void findKNNRecur(int k, KDNode currentNode, double[] coordinates) {
<span class="fc bfc" id="L313" title="All 4 branches covered.">    if (currentNode == null || currentNode.getValue() == null) {</span>
<span class="fc" id="L314">      return;</span>
    }
<span class="fc" id="L316">    double dist = Common.calcDistance(currentNode.getValue().getCoordinate(), coordinates);</span>
<span class="fc" id="L317">    currentNode.distance = dist;</span>
<span class="fc" id="L318">    bpq.add(currentNode);</span>

    /* Recursively compares the new coordinate with the currentNode,
     * looks into the correct subtree for close neighbors
     */
<span class="fc" id="L323">    int cd = currentNode.getDimension();</span>
<span class="fc" id="L324">    boolean wentRight = false;</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">    if (coordinates[cd] &lt; currentNode.getValue().getCoordinate()[cd]) {</span>
<span class="fc" id="L326">      findKNNRecur(k, currentNode.left, coordinates);</span>
    } else {
<span class="fc" id="L328">      wentRight = true;</span>
<span class="fc" id="L329">      findKNNRecur(k, currentNode.right, coordinates);</span>
    }

    /* If the candidate hypersphere crosses this splitting plane (hence there
     * potentially exists closer neighbors on the other side of the plane),
     * or if the bpq is not filled yet,
     * examines the other subtree.
     */
<span class="fc" id="L337">    double distanceToOtherSide =</span>
<span class="fc" id="L338">        Math.abs(currentNode.getValue().getCoordinate()[cd] - coordinates[cd]);</span>
<span class="fc" id="L339">    KDNode bpqHead = (KDNode) bpq.peekLowestPriority(); //casting?</span>
<span class="fc bfc" id="L340" title="All 4 branches covered.">    if ((bpq.size() &lt; k) || bpqHead.distance &gt; distanceToOtherSide) {</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">      if (wentRight) {</span>
<span class="fc" id="L342">        findKNNRecur(k, currentNode.left, coordinates);</span>
      } else {
<span class="fc" id="L344">        findKNNRecur(k, currentNode.right, coordinates);</span>
      }
    }
<span class="fc" id="L347">  }</span>

  /* Global variable to store neighbors within radius */
  private PriorityQueue&lt;KDNode&gt; pq;

  /** Finds all elements that are within a fixed radius from a point.
   * @param r radius
   * @param coordinate the center coordinate to search from
   * @return list of elements within the radius
   */
  public List&lt;T&gt; findWithinRadius(double r, double[] coordinate) {
<span class="fc" id="L358">    pq = new PriorityQueue(Collections.reverseOrder());</span>
<span class="fc" id="L359">    findWithinRadiusRecur(r, root, coordinate);</span>
<span class="fc" id="L360">    List&lt;KDNode&gt; foundNodes = pqToList(pq);</span>
<span class="fc" id="L361">    List&lt;T&gt; output = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">    for (KDNode node : foundNodes) {</span>
<span class="fc" id="L363">      output.add(node.getValue());</span>
<span class="fc" id="L364">    }</span>
<span class="fc" id="L365">    return output;</span>
  }

  /**
   * Recursive helper function for finding elements within a radius.
   * @param r radius
   * @param currentNode urrentNode current node being looked at during recursion
   * @param coordinates coordinate around which to look for
   */
  private void findWithinRadiusRecur(double r, KDNode currentNode, double[] coordinates) {
<span class="fc bfc" id="L375" title="All 2 branches covered.">    if (currentNode == null) {</span>
<span class="fc" id="L376">      return;</span>
    }
<span class="fc" id="L378">    double dist = Common.calcDistance(currentNode.getValue().getCoordinate(), coordinates);</span>
<span class="fc" id="L379">    currentNode.distance = dist;</span>

<span class="fc bfc" id="L381" title="All 2 branches covered.">    if (dist &lt;= r) {</span>
<span class="fc" id="L382">      pq.add(currentNode);</span>
    }

    /* Recursively search the half of the tree that contains the test point. */
<span class="fc" id="L386">    int cd = currentNode.getDimension();</span>
<span class="fc" id="L387">    boolean wentRight = false;</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">    if (coordinates[cd] &lt; currentNode.getValue().getCoordinate()[cd]) {</span>
<span class="fc" id="L389">      findWithinRadiusRecur(r, currentNode.left, coordinates);</span>
    } else {
<span class="fc" id="L391">      wentRight = true;</span>
<span class="fc" id="L392">      findWithinRadiusRecur(r, currentNode.right, coordinates);</span>
    }
    /* If the candidate hypersphere crosses this splitting plane, look on the
     * other side of the plane by examining the other subtree.
     */
<span class="fc bfc" id="L397" title="All 2 branches covered.">    if (Math.abs(currentNode.getValue().getCoordinate()[cd] - coordinates[cd]) &lt;= r) {</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">      if (wentRight) {</span>
<span class="fc" id="L399">        findWithinRadiusRecur(r, currentNode.left, coordinates);</span>
      } else {
<span class="fc" id="L401">        findWithinRadiusRecur(r, currentNode.right, coordinates);</span>
      }
    }
<span class="fc" id="L404">  }</span>

  /**
   * Returns a list containing all nodes in this queue, preserving priority order.
   * @param q original queue
   * @return a list of elements from the queue
   */
  private List&lt;KDNode&gt; pqToList(PriorityQueue q) {
<span class="fc" id="L412">    PriorityQueue pqTemp = new PriorityQueue&lt;&gt;(q);</span>
<span class="fc" id="L413">    List list = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">    for (int i = 0; i &lt; q.size(); i++) {</span>
<span class="fc" id="L415">      list.add(pqTemp.poll());</span>
    }
<span class="fc" id="L417">    Collections.reverse(list);</span>
<span class="fc" id="L418">    return list;</span>
  }

  /**
   * Returns the height of a tree.
   * @return height
   */
  public int height() {
<span class="fc" id="L426">    return height(root);</span>
  }

  /**
   * Recursive function to calculate the height of a tree.
   * @param node current node being looked at
   * @return height of the current node
   */
  private int height(KDNode node) {
<span class="fc bfc" id="L435" title="All 2 branches covered.">    if (node == null) {</span>
<span class="fc" id="L436">      return 0;</span>
    } else {
      /* compute  height of each subtree */
<span class="fc" id="L439">      int lheight = height(node.left);</span>
<span class="fc" id="L440">      int rheight = height(node.right);</span>

      /* use the larger one */
<span class="fc bfc" id="L443" title="All 2 branches covered.">      return (lheight &gt; rheight) ? (lheight + 1) : (rheight + 1);</span>
    }
  }

  /**
   * Prints a tree.
   */
  public void printTree() {
<span class="fc" id="L451">    int h = height(root);</span>
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">    for (int i = 1; i &lt;= h; i++) {</span>
<span class="fc" id="L453">      printGivenLevel(root, i);</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">      if (i == h) {</span>
<span class="fc" id="L455">        return;</span>
      } else {
<span class="fc" id="L457">        System.out.println();</span>
      }
    }
<span class="nc" id="L460">  }</span>

  /**
   * Gets value of root node.
   * @return value of root node
   */
  public T getNodeValue() {
<span class="fc" id="L467">    return root.getValue();</span>
  }

  /**
   * Gets value of node left of root node.
   * Used for testing.
   *
   * @return value of node left of root node
   */
  public T getLeftNodeValue() {
<span class="fc" id="L477">    return root.getLeft().getValue();</span>
  }

  /**
   * Gets value of node right of root node.
   * Used for testing.
   *
   * @return value of node right of root node
   */
  public T getRightNodeValue() {
<span class="fc" id="L487">    return root.getRight().getValue();</span>
  }

  /**
   * Prints the nodes at a given level.
   * @param node current node
   * @param level current level
   */
  private void printGivenLevel(KDNode node, int level) {
<span class="fc bfc" id="L496" title="All 2 branches covered.">    if (node == null) {</span>
<span class="fc" id="L497">      System.out.print(&quot;/ &quot;);</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">    } else if (level == 1) {</span>
<span class="fc" id="L499">      System.out.print(node.toString() + &quot; &quot;);</span>
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">    } else if (level &gt; 1) {</span>
<span class="fc" id="L501">      printGivenLevel(node.left, level - 1);</span>
<span class="fc" id="L502">      printGivenLevel(node.right, level - 1);</span>
    }
<span class="fc" id="L504">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>